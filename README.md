# 《循序渐进Vue.js3前端开发实战》
-----

### 自学过程中的心得体会
1. 无论是看书还是看视频学，看一万遍看到倒背如流，不自己手敲也学不会。对于书上或者是视频里讲的小demo，跟着敲了一遍之后一定要不看答案自己从头写一遍(所有my开头的文件都是我不看答案自己实现的demo)。 完全自己主动的去思考，产生思路，遇到问题解决问题的过程才是真正的锻炼。
<br>
2. Vue的官方中文文档写的真的是很好，经常会有遇到一个问题去网上搜各种帖子终于解决之后才发现关于这部分内容官方文档上已经解释的清清楚楚了，所以多看官方文档很重要，有事没事就可以拿来翻一翻，比如上下班地铁上。
<br>
3. 对于纯新手小白来说单靠看文档学肯定不太现实，但是在第一遍学会了之后，如果有些遗忘的地方就去看文档，把官方文档当一个备忘录来查阅我觉得很合适。比如在自定义组件上使用v-model我一开始看文档也不是很懂，通过网上搜加自己手敲完全理解了之后再回过头看文档，感觉真是大大的通透，官方文档上讲的其实很明白了。
<br>
4. 学Vue纯粹是因为兴趣，Vue也算是我第一个完全自学的主流技术，所以我会想尽量学的系统全面，理解透一些。我个人感受是（不一定对啊），学一门技术如果不求速成的话其实不必太早就做实际项目，多给自己一点时间把新知识理解的更深刻。当还没有真正地把技术放到现实场景中使用的时候，还不知道哪些内容在实际运用中常用哪些不常用，因此会对每一个点都平等的抱有钻研精神愿意深究；实际使用过之后，知道了一些内容其实是不重要的，就会不想花心思去研究了。（比如python里的kargs，我面试都被问两次了，但是学习和工作中根本就没用过导致我到现在也没去查过嘿嘿）
<br>
5. 对于某一个新知识点，感觉自己理解之后立刻就尝试把自己的理解写下来，尽可能表述的清晰直白，一方面是当作笔记，另一方面是把自己的理解用文字表述的过程中会不断引导大脑对这个内容进行反复思考，为求表述清楚反复措辞的过程中经常会对知识产生更深的理解（个人经验，亲测有效），因为只有先理解足够透彻才能说得明白。

-----

### 学习Vue的过程中(看上去实际用处不大但我就是不想通不舒服)的思考
1. Vue的数据响应式，如果一个变量是响应式的，那么在这个变量值改变的时候会自动重新运行依赖于这个变量的函数（什么computed， watch，methods里的都是函数对吧）。为什么data里的数据改变了之后渲染出来的页面会自动改变，因为页面其实也是render函数渲染出来的，如果页面依赖的data里的值变了，render函数当然重新运行，页面自然改变了。传给子组件的props是响应式的其实也是这个原理，毕竟porps写在模版里，就是模版的一部分，data到模版肯定是响应式。
<br>
一句话说明白Vue的数据响应式实现原理: 通过proxy换掉对象的get和set方法，在get里获取到哪些函数用了它，set里重新运行那些函数，也就是每次值更新都重新运行依赖它的函数
<br>
1. provide为什么不是响应式呢，因为在provide里写法是someValue: this.someValue对吧，真正procide出去的变量是someValue，给someValue用":"赋值了this.someValue的值，也就是说从this.someValue到someValue没有经过任何的函数，就是一个:赋值操作。所以哪怕右边的数据是响应式，改变了之后也不会对左边的someValue产生任何影响，因为:不是函数不会重新运行。官方文档上也写了，想要provide响应式就把:右边的用computed()包一层。
<br>
1. 上一条里提到了:不是响应式，=自然也不是，那如果只需要获取一个响应式数据某一刻的值的并且不希望跟着变，就可以用:或者=来实现响应式截断。比如一个子组件接收的props里有一个value，我现在要渲染value第一次传进来的值，之后value再怎么改跟我无关，要怎么实现？如果子组件在模版里{{value}}，那父组件传进来value变了之后显示的数据也变了。想要截断响应式就在data里新定义一个比如myValue:this.value，然后子组件模版里{{myValue}}，这样就实现了永远展示value刚传进来的值，不随着value改变。又或者给自定义指令传一个响应式数据，指令内部拿到元素el并把el的placeholder用=赋为传进来的响应式数据的值，挂上指令的input框的placeholder也会是传入的响应式数据某一刻的值并且后续不跟着变（见6.4的directive.html）。通过:或者=让一个响应式变量给另一个变量赋值，可以截断响应式，取得响应式数据某一刻的值并不随着响应式数据后续的改变而改变。
<br>
1. provide想实现响应式还有一种办法，偶然间在网上看到的，那就是把要provide的数据在data里定义的时候包一个引用类型比如对象，然后provide这个引用类型。比如data里来一个obj:{value: 0}，provide里provideValue: this.obj，inject的组件里取provideValue.value。这么写如果在provide的组件里更改obj.value，inject的组件获取的provideValue.value也会跟着变。原因再简单不过了甚至和vue本身没有半点关系，就是引用类型传递的是地址这一特性。procide组件和inject组件手里都有同一个引用类型的地址，访问到的直接就是同一个值了，当然是你变我也变，甚至跟响应式原理都不沾边，就像一个咱俩都能访问也能更改的全局变量。<br>
vue是单向数据流，子组件无论是props里的还是inject里的都只读，但是如果是引用类型，比如provideValue，我不更改provideValue本身而是更改provideValue.value，这样是可以的。inject组件里更改provideValue.value，provide组件里的obj.value也会变（props传值的情况也一样）（压根就是同一个值不变就有鬼了），这等于是实现了跨组件的双向数据流？（但我猜这种做法肯定是极不推荐的）不仅是provide，props传引用类型可以实现，甚至还可以给自定义指令传引用类型然后在指令内实现的生命周期方法里更改传进来的引用类型内部的值进而影响外部。 也就是说，不仅是组件间，不同的作用域只要拿到同一个引用类型的地址，相互之间就都可以互相实现通信了。（6.2的my_provide.html）
<br>
1. 在写其他语言的时候经常会有一种写法就是for循环每循环一次就给某个变量++，学到v-for的时候我就想怎么样能实现v-for渲染一个就给data里一个数据++呢（虽然好像没啥实际用处）。学到了生命周期之后我想到可以让v-for渲染的子组件的生命周期里emit一个事件让父组件里某个数据++，但是这样的话如果v-for渲染的是原生元素，不能写生命周期那就实现不了。后来学到了自定义指令可以给原生html元素加上生命周期实现，以及发现了第三点里提到的串引用类型实现通信，通过在父组件里定义一个引用类型传给自定义指令，指令内部给引用类型里某个值++就实现了。<br>
亲测发现传引用类型的方式和emit的方式效果上没有任何区别，神奇的是自定义指令实现生命周期挂到子组件上和子组件内部实现同样的生命周期，产生的效果不一样，详情请见6.4的复现.html，实在是有点太复杂了还没彻底研究透。推测是自定义指令实现的生命周期和组件内实现生命周期机制不完全相同，最早能访问到props和provide的生命周期也不相同，两个因素结合产生的效果。
<br>
1. 在自定义组件上使用v-model是学到现在觉得最难理解的。其实本身也没有那么难，第一次学没懂原因就是最关键的在自定义组件上用v-model会被编译器展开这一点书上没有说清楚，理解了就明白其实v-model本质上就是给子组件提出了要求，子组件只要按要求实现，v-model就能正确生效了。类比一下就是，我要你这个函数接受两个参数一个int一个string，反正我调用你的时候会这么传，你实现为可以这么调用那就没事，你没按照要求实现那就玩不了。
<br>
1. 选项式api和组合式api本质上的区别在于组件内部变量的声明方式。可以认为组件里每一个声明的变量或者方法都有自己的种类，比如data里的种类是data，methods里的函数种类是methods等。选项式api的做法是，先声明种类再列出这个种类下有些啥，比如先来一个data，然后是data里有1，2，3，然后是computed，computed下面有a，b，c，这种做法的结果就是，相同种类的变量必须写在一起。组合式api可以看作是先声明变量再声明变量的种类，比如先来个a再声明a是data（ref），来个b再声明b是watch（），这样的方式没有相同类型必须写在一起的限制，可以随意组合，那么好处就是可以根据逻辑来组合，把用来实现同一个功能的代码写在一起，提升可读性。
